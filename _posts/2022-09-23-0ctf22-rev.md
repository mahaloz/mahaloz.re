---
title: "Tips and tricks for reversing foregin architecture games"
layout: post
tags: [ctf, reversing, game-hacking]
description: "game hacking tldr"
---

If you've played enough CTF, or lived a long enough live as a curious Computer Person, it's likely you've run into a device/peice of software that is built on an architecture you've never reversed before. In this years edition of [0ctf](), I encounterd something similar, and I thought I'd make a little post about some common tricks I've used in these situations based on this challenge.

# The Challenge
In this challenge we are provided with only a single file called [game.bin](). The description for the challenge only says "back to the 90s." 

Like any random file that I am given, it's best to see if `file` has any knolwedge of it:
```bash
Î» file game.bin
game.bin: Vectrex ROM image: "VECTOR_GAME\200"
```

As thus begins the introduction to a completly foregin device with an archetecture I have not reversed before. 

# The Vectrex Console
For instances like this, Wikipedia tends to be a great resource in getting general knowledge. The [Vectrex](https://en.wikipedia.org/wiki/Vectrex#Technical_specifications) page already tells us the most important thing: that the console's circuit board, i.e. it's architecture, is a [Motorola 6809](https://en.wikipedia.org/wiki/Motorola_6809). I've heard other CTFers refer to this arch as m68k. 

![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7a/Vectrex-Console-Set.jpg/800px-Vectrex-Console-Set.jpg)

m68k in this case is an 8bit architecture that supports some 16 bit operations, which means we will likely only ever be dealing with 1 byte at a time. This is like [ARM Thumb Mode](https://stackoverflow.com/questions/10638130/what-is-the-arm-thumb-instruction-set). The game we were given is essentially a program for this system which is full of m68k instructions wrapped by some assets and loading information. 

# Reversing Questions
Understanding the very basics of this program is important, but it still leaves a lot of questions. These questions are usually the same questions I ask whenever reversing something not mainstream. Most of them are inspired by my mentor [@fish](https://ruoyuwang.me/).

1. What tools did the author (and normal devs of the platform) use to make this program? 
2. If this is a program wrapped in something deeper, where is the entry point? How do emulators find the entry point? 
3. Do any revealing strings tell us more about the programs origins?
4. If the flag is not a hardcoded string, how are they hiding it?

We'll attack these in order to get a better understanding of the program.

# Tooling
After soom google searching with phrases like ["vectrex debugger ide"](https://www.google.com/search?q=vectrex+debugger+ide), a [blog](http://vide.malban.de/) by a somewhat active developer shows us what people use to develop in this platform: [VIDE](http://vide.malban.de/download): Vecrex Integrated Development Enviornment.   Blogs from active developers of one-off's like this are usually gold mines for finding information on how to understand this platform. 

The "IDE" is somewhat archaic, but hey, it works!
![]({{ site.baseurl }}/assets/images/0ctf22-rev/pic1.png)

The IDE allows us to step debug, dump memory, and even modify memory and registers as it runs! It's a full on debugger that also gives us insight into what the disassembly looks like when correctly assembled. This combined with a [m6809 reference sheet](https://colorcomputerarchive.com/repo/Documents/Books/Motorola%206809%20and%20Hitachi%206309%20Programming%20Reference%20(Darren%20Atkinson).pdf) we found from googling, we are set! A reference sheet is needed when you don't understand how an arch works.

During this scouting phase of tools, I also found a simple emulator called [vecx](https://github.com/jhawthorn/vecx), which was preferred because of how easy the code was to understand. I'd say it's always useful to have a simple reference to see how other noobs approached the same problem. The emulator even included an entire emulation implementation of [m6809 in simple C](https://github.com/jhawthorn/vecx/blob/master/e6809.c). This was useful because it also allowed us to debug it quickly and find that the entry point of the program is `0x1e`. You can reproduce this by setting a breakpoint in the very first `read8` of the program.

With that squared away, we now understand how other people develop in this arch. The last part we need is some form of static analysis for this ROM. In most cases like this, there will not be some plugin ready availble for your decompiler. At this point you can make the time decision wether implementing an entire loader, which essentially unwraps the object and tells the decompiler where the code begins, or just manually mark code youself. In [another writeup](https://nevesnunes.github.io/blog/2022/09/19/CTF-Writeup-0CTF-2022-vintage-part1+2.html#part-2) of this same challenge, which is done spectacularly, the author invests his time in writing his own [loader for ghidra](https://github.com/nevesnunes/ghidra-vectrex-loader). 


# Static Analysis
When running the game, as shown in the IDE picture, it simply asks for a password. It's eight chars, which is outside the bruteforceable range for a CTF. At this moment we should be thinking about two more questions:
1. Is verification time constant? 
2. Is each char verification dependent on the entire password? 

Answer 1 is tricky because we can only debug this program once it is being emulated, which makes it extremly hard to detect changes in verification of something like `AAAAAAAA` and `BAAAAAAA`. Instead, we keep 2 in mind. 

For static analysis we will be using IDA, but you should be able to do this in both Ghidra and Binja. For IDA, we need to manually mark the start of the code section becuase IDA has no knowledge of this binary format; however, it does understand m68k instructions. In IDA, going to the EP that we discovered earlier, `0x1e`, if we type `C` while over it we get dissasembled instruction with general function boundary guesses from IDA. 

We are left with the following functions:
```c
sub_974	
sub_A5F	
sub_1470
sub_14D7
sub_1A63
sub_1C60
sub_219F
sub_2549
sub_2851
sub_2D26
sub_2F3C
sub_3274
sub_33C6
sub_3415
sub_350E
sub_3577
sub_35A5
sub_4080
sub_4085
sub_4094
sub_40A5
sub_40AC
sub_40BF
sub_40F4
```

Decompilation won't be an option here, but we can still use the CFG and XREFS to get a better understanding of this program. At this point in reversing you may be tempted to just jump into the entry point and _go off_, but a wise reverser once told me:
>"Don't start where the program starts. Start where the interesting things start!" 

At first, this seems like a stupid quote, but I promise it has actual application. A general good advice of reversing any program is finding the code location of output you associate to a state, and then finding so-called beacons. Beacons are structures and patterns that you recognize from programming or reversing. They have been a somewhat hot-topic recently in research papers into the area of [qualitative analysis of reverse engineering](https://www.usenix.org/system/files/sec22-mantovani.pdf). In those papers, they have recently shown that a breadth-first-search process that is both quick and precise tends to be the most effective when reversing. 

What does this all have to do with getting the password? Well, we know the state we _dont want_. 

![]({{ site.baseurl }}/assets/images/0ctf22-rev/pic2.png)

We are looking for a single control flow point that changes access to strings based on its value. After rapid clicking through the entry function callees, we find only 2 places that compare a value and then take rapidly different branches. The interesting one is here:
```asm
loc_2FA3:                              
ldb     3,s
cmpb    #1
lbeq    loc_30A5
ldb     #8
leax    ,y
jsr     sub_1A63
tstb
lbne    loc_3185
```

I calls the function at location `0x1a63`, checks if it's `1`, then branches to places with a series of calls, loops and printouts if correct. If false, its a quick succession to what looks like an exit. The hunch here is that we've found some kind of authenticator. 

Recall our password is 8 bytes long. We look into the CFG of this function:
![]({{ site.baseurl }}/assets/images/0ctf22-rev/pic3.png)

If that is hard to see, it looks like 8 things are being compared. If one fails, the compare chain ends early and outputs 0. If it gets to the end, it outputs 1. Since we can see all the addresses being compared, we throw it in the debugger and confirm they are what we think they are. 

When we look in the debugger at the RAM offset of `116`, we see our input `AAAAAAAA` has been changed into something mangled. After seeing this, its safe to assume that the flag will also be mangled in the same way. Using this, we can now answer our reverser question of `if all inputs effect the check`. It very much seems like it does not, but we can confirm that buy running it through each char in the alphabet.

After 2 attempts, which gets us a `B`, the first if-stmt passes in the check. There are only 8 chars, and each char only has 26 options... that is bruteforceable by hand! After 10 mins of guessing with a teammate, [@zammo](), we guess all the chars of the key:
```
BLACKKEY
```

What does it mean? I have no idea. 

# A Recap of Techniques 
We did the following:
1. Find how normal people dev in this arch
2. Use those tools to learn how the program starts and uses memory 
3. Use that knolwedge to make tools work 
4. Question how authentications works 
5. Quickly search for patterns that match assumptions made in 4 

I think the important takeaway from this section of the challenge was that **much** of the code you see is useless. This is a game so there will be an insane amount of code that is just for running the game and simulating things like [game ticks](https://gamedev.stackexchange.com/questions/81608/what-is-a-tick-in-the-context-of-game-development). It was important that we just found structures that look familar quickly and disregarded most other things. 

# The Real Game
After you get the password you get to the second part of the game:
![]({{ site.baseurl }}/assets/images/0ctf22-rev/pic4.png)

Instead of going in-depth to the rest of this challenge, I again say go check out [this blog](https://nevesnunes.github.io/blog/2022/09/19/CTF-Writeup-0CTF-2022-vintage-part1+2.html#part-2) if you are looking for a technical writeup of the second part. I will instead give the overview and tricks I found useful 

In this second part of the game you are tasked with collecting coins (and completing an easter egg), then going to the flag at the end of the map. I find the game very hard to play, but zammo thought it was fun (he was also good, lol).

# Tricks for Game Hacking
## Make a fast workflow 
In this game if you fell off you died and had to go back to the password prompt, which was very painful. Instead of waisting time having to restart the game it is useful to find ways to jump around execution points in the game and reverse actions. Because we are running in an emulator we are blessed with the ability to "undo" instructions. In our workflow we had:
1. A quick `set $pc` command to get us back to the start of the game
2. A breakpoint set for the function called if you fall off 

In the event of 2, we could undo the last few instructions to get back on the platform. 

## Observe Memory 
Early on in playing we had a memory dump of the game always up on the screen. This showed us which values changed more than others. Through this we were able to find our `(x, y)` coordinates storage location, our coin storage location, flags for winning or losing, and counter for jumps (suspicious). Zammo actually found quite a bit of information like this.

Always observering memory gives you ample oppourtunity to see where important variables are. In the case of this game, knowing a jump counter existed was crucial. 

## Lookup Suspicious Constants and Patterns
I should've done this earlier in my reversing, but there was a strange pattern of 0-256 being set into an array then shuffled. They then used that value for xoring. I found it very weird. Once looking this up a little more, I found that this was just an inlined implementation of [RC5](https://en.wikipedia.org/wiki/RC5).

Any time you see a large constant or a strange loop of setting many constants, just do a quick google search for them. 

## Identify External Functions
Lastly, identifying external functions in games is probably the most important thing you can do when reversing large games. Usually, I like to start with finding which function is responsible for printing graphics to the screen. In this case, that information is what allowed us to find all prints (which is a small location of places), and find where the second flag is eventually decrypted and printed. 

When you can, try identify what looks like user set memory access and library set acccess. In embedded games like this, it will usually be made more obvious by access to ROM and RAM. 

# Wrapup 
I hope you enjoyed this quick overview of hacking around in another architecture. If you take anything away from this posts, its that you often need to move fast when reversing and make a lot of assumptions that you confirm later (usually with dynamic analysis). See you next time \o. 